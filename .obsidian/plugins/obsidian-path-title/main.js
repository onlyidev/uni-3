/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __export = (target, all) => {
  __markAsModule(target);
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toModule = (module2) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// main.ts
__export(exports, {
  default: () => main_default
});

// src/plugin.ts
var import_obsidian = __toModule(require("obsidian"));

// src/constants.ts
var defaultSettings = {
  fontSize: "75%",
  pathSettings: []
};

// src/utils.ts
function applyPathSettings(allPathSettings, path) {
  return allPathSettings.reduce((currentPath, pathSettings) => {
    if (pathSettings.match) {
      if (pathSettings.type === "regexp" || pathSettings.type === "fuzzy") {
        const re = new RegExp(pathSettings.match, "gu");
        return currentPath.replace(re, pathSettings.replace);
      }
      if (pathSettings.type === "folder") {
        return currentPath.split("/").map((folder) => {
          if (folder === pathSettings.match) {
            return pathSettings.replace;
          }
          return folder;
        }).join("/");
      }
      if (pathSettings.type === "exact") {
        if (currentPath === pathSettings.match) {
          return pathSettings.replace;
        }
      }
      if (pathSettings.type === "text") {
        return currentPath.replace(pathSettings.match, pathSettings.replace);
      }
    }
    return currentPath;
  }, path);
}
function getAllFolderNames(folderPaths) {
  const folderNameSet = folderPaths.reduce((result, path) => {
    if (path !== "/") {
      for (const folderName of path.split("/")) {
        result.add(folderName);
      }
    }
    return result;
  }, new Set());
  return Array.from(folderNameSet);
}
function arrayToChoices(array) {
  return array.reduce((result, item) => {
    result[item] = item;
    return result;
  }, {});
}
function escapeQuotes(s) {
  return s.replace('"', '\\"');
}
function escapeSlashes(s) {
  return s.replace("/", "\\/");
}

// src/plugin.ts
function getFolderPaths(app) {
  const folders = [];
  import_obsidian.Vault.recurseChildren(app.vault.getRoot(), (f) => {
    if (f instanceof import_obsidian.TFolder) {
      folders.push(f.path);
    }
  });
  folders.sort();
  return folders;
}
var PathTitlePlugin = class extends import_obsidian.Plugin {
  onload() {
    return __async(this, null, function* () {
      yield this.loadSettings();
      this.addSettingTab(new PathTitleSettingTab(this.app, this));
      this.registerEvent(this.app.workspace.on("file-open", () => {
        this.setPaneTitles();
      }));
      const onRename = (0, import_obsidian.debounce)(() => {
        this.setPaneTitles();
      }, 100);
      this.registerEvent(this.app.vault.on("rename", onRename));
      this.app.workspace.onLayoutReady(() => {
        this.setPaneTitles();
      });
    });
  }
  setPaneTitles() {
    this.app.workspace.iterateAllLeaves((leaf) => {
      if (leaf.view instanceof import_obsidian.FileView && leaf.view.file) {
        const fileView = leaf.view;
        const path = fileView.file.parent ? fileView.file.parent.path : "";
        const replacedPath = applyPathSettings(this.settings.pathSettings, path);
        if (replacedPath) {
          leaf.view.containerEl.addClass("path-title-plugin-has-path");
          const headerTitleContainerEl = leaf.view.containerEl.find(".view-header-title-container");
          const isVerticalTitle = getComputedStyle(headerTitleContainerEl).writingMode === "vertical-lr";
          if (isVerticalTitle) {
            leaf.view.containerEl.addClass("path-title-plugin-has-vertical-title");
          }
          if (!leaf.view.containerEl.find(".path-title-plugin-path-title-container")) {
            const pathContainerEl = leaf.view.containerEl.createEl("div");
            pathContainerEl.addClass("path-title-plugin-path-title-container");
            const titleEl = headerTitleContainerEl.find(".view-header-title");
            const titleStyle = window.getComputedStyle(titleEl);
            pathContainerEl.style.lineHeight = titleStyle.getPropertyValue("line-height");
            pathContainerEl.style.fontSize = titleStyle.getPropertyValue("font-size");
            pathContainerEl.style.fontWeight = titleStyle.getPropertyValue("font-weight");
            headerTitleContainerEl.prepend(pathContainerEl);
            const pathEl = pathContainerEl.createEl("div");
            pathEl.addClass("path-title-plugin-path-title");
            pathContainerEl.append(pathEl);
            const pathTextEl2 = pathContainerEl.createEl("span");
            pathTextEl2.addClass("path-title-plugin-path-title-text");
            pathEl.append(pathTextEl2);
          }
          leaf.view.containerEl.find(".path-title-plugin-path-title-container").style.display = "";
          const pathTextEl = leaf.view.containerEl.find(".path-title-plugin-path-title-text");
          pathTextEl.setText(replacedPath);
          leaf.view.containerEl.style.setProperty("--path-title-plugin-font-size", this.settings.fontSize || defaultSettings.fontSize);
        } else {
          this.cleanupLeaf(leaf);
        }
      }
    });
  }
  cleanupLeaf(leaf) {
    const pathContainerEl = leaf.view.containerEl.find(".path-title-plugin-path-title-container");
    if (pathContainerEl) {
      pathContainerEl.detach();
    }
    leaf.view.containerEl.removeClass("path-title-plugin-has-path");
    leaf.view.containerEl.removeClass("path-title-plugin-has-vertical-title");
    leaf.view.containerEl.style.removeProperty("--path-title-plugin-font-size");
  }
  onunload() {
    this.app.workspace.iterateAllLeaves((leaf) => {
      if (leaf.view instanceof import_obsidian.FileView && leaf.view.file) {
        this.cleanupLeaf(leaf);
      }
    });
  }
  loadSettings() {
    return __async(this, null, function* () {
      this.settings = Object.assign({}, defaultSettings, yield this.loadData());
    });
  }
  saveSettings() {
    return __async(this, null, function* () {
      yield this.saveData(this.settings);
      this.setPaneTitles();
    });
  }
};
var replacementTypeToUi = {
  exact: {
    heading: (match) => `Path exactly matches "${escapeQuotes(match)}"`,
    matchName: "Matching Path",
    matchDesc: "Exact path that will be replaced",
    replaceName: "Replacement Path",
    replaceDesc: "Path that will replace matching path"
  },
  folder: {
    heading: (match) => `Folder in path exactly matches "${escapeQuotes(match)}"`,
    matchName: "Matching Folder",
    matchDesc: "Exact folder in path that will be replaced",
    replaceName: "Replacement Folder",
    replaceDesc: "Folder that will replace matching folder"
  },
  text: {
    heading: (match) => `Text anywhere in path matches "${escapeQuotes(match)}"`,
    matchName: "Matching Text",
    matchDesc: "Text anywhere in path that will be replaced",
    replaceName: "Replacement Text",
    replaceDesc: "Text that will replace matching text"
  },
  regexp: {
    heading: (match) => `Path matches regular expression /${escapeSlashes(match)}/`,
    matchName: "Matching Regular Expression",
    matchDesc: "Regular expression to match part of path (or full path) that will be replaced",
    replaceName: "Replacement Text",
    replaceDesc: "Text that will replace the text that matches the regular expression, can use $1, $2, etc. for groups found in match"
  }
};
var PathTitleSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
    this.undoReplacementEntry = null;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", {}, (el) => {
      el.setText("General Settings");
    });
    new import_obsidian.Setting(containerEl).setName("Path Font Size").setDesc(`Font size of the path`).addDropdown((dropdown) => {
      dropdown.addOptions({
        "100%": "Large",
        "75%": "Medium",
        "63%": "Small"
      }).setValue(this.plugin.settings.fontSize || defaultSettings.fontSize).onChange((value) => __async(this, null, function* () {
        this.plugin.settings.fontSize = value;
        yield this.plugin.saveSettings();
      }));
    });
    let currentSelectedMappingPath = "";
    let currentSelectedMappingFolder = "";
    containerEl.createEl("h2", {}, (el) => {
      el.setText("Path Replacement Settings");
    });
    new import_obsidian.Setting(containerEl).setName("Exact Path Replacement").setDesc(`Select one of your folders, and click the "+" button to add an exact path replacement for that path below`).addDropdown((dropdown) => {
      dropdown.addOptions(arrayToChoices(getFolderPaths(this.plugin.app)));
      currentSelectedMappingPath = dropdown.getValue();
      dropdown.onChange((value) => {
        currentSelectedMappingPath = value;
      });
    }).addExtraButton((button) => {
      button.setIcon("plus-with-circle").setTooltip("Add Replacement").onClick(() => __async(this, null, function* () {
        this.plugin.settings.pathSettings.push({
          type: "exact",
          match: currentSelectedMappingPath,
          replace: currentSelectedMappingPath
        });
        this.undoReplacementEntry = null;
        yield this.plugin.saveSettings();
        this.display();
      }));
    });
    new import_obsidian.Setting(containerEl).setName("Exact Folder Replacement").setDesc(`Select one of your folder names, and click the "+" button to add an exact folder replacement for that folder in any path`).addDropdown((dropdown) => {
      dropdown.addOptions(arrayToChoices(getAllFolderNames(getFolderPaths(this.plugin.app)).sort()));
      currentSelectedMappingFolder = dropdown.getValue();
      dropdown.onChange((value) => {
        currentSelectedMappingFolder = value;
      });
    }).addExtraButton((button) => {
      button.setIcon("plus-with-circle").setTooltip("Add Replacement").onClick(() => __async(this, null, function* () {
        this.plugin.settings.pathSettings.push({
          type: "folder",
          match: currentSelectedMappingFolder,
          replace: currentSelectedMappingFolder
        });
        this.undoReplacementEntry = null;
        yield this.plugin.saveSettings();
        this.display();
      }));
    });
    new import_obsidian.Setting(containerEl).setName("Other Path or Folder Replacement").setDesc("Add a replacement for a different exact path or folder than one listed above").addButton((button) => {
      button.setButtonText("Add Other Path");
      button.onClick(() => __async(this, null, function* () {
        this.plugin.settings.pathSettings.push({
          type: "exact",
          match: "",
          replace: ""
        });
        this.undoReplacementEntry = null;
        yield this.plugin.saveSettings();
        this.display();
      }));
    }).addButton((button) => {
      button.setButtonText("Add Other Folder");
      button.onClick(() => __async(this, null, function* () {
        this.plugin.settings.pathSettings.push({
          type: "folder",
          match: "",
          replace: ""
        });
        this.undoReplacementEntry = null;
        yield this.plugin.saveSettings();
        this.display();
      }));
    });
    new import_obsidian.Setting(containerEl).setName("Text or Regular Expression Replacement").setDesc("Add a text or regular expression replacement to match and replace partial text or a regular expression").addButton((button) => {
      button.setButtonText("Add Text");
      button.onClick(() => __async(this, null, function* () {
        this.plugin.settings.pathSettings.push({
          type: "text",
          match: "",
          replace: ""
        });
        this.undoReplacementEntry = null;
        yield this.plugin.saveSettings();
        this.display();
      }));
    }).addButton((button) => {
      button.setButtonText("Add Regular Expression");
      button.onClick(() => __async(this, null, function* () {
        this.plugin.settings.pathSettings.push({
          type: "regexp",
          match: "",
          replace: ""
        });
        this.undoReplacementEntry = null;
        yield this.plugin.saveSettings();
        this.display();
      }));
    });
    const entries = Array.from(this.plugin.settings.pathSettings.entries());
    if (this.undoReplacementEntry) {
      entries.splice(this.undoReplacementEntry[0], 0, this.undoReplacementEntry);
    }
    for (const [index, pathSettings] of entries) {
      let setSettingUi = function(settings) {
        const emptyMessage = !settings.match ? " (will not match any path)" : "";
        headingEl.setText(`${index + 1}. ${replacementTypeToUi[settings.type].heading(settings.match)}${emptyMessage}`);
        if (matchSetting && replacementSetting) {
          matchSetting.setName(replacementTypeToUi[settings.type].matchName);
          matchSetting.setDesc(replacementTypeToUi[settings.type].matchDesc);
          replacementSetting.setName(replacementTypeToUi[settings.type].replaceName);
          replacementSetting.setDesc(replacementTypeToUi[settings.type].replaceDesc);
        }
      };
      if (this.undoReplacementEntry && pathSettings === this.undoReplacementEntry[1]) {
        containerEl.createDiv({ cls: "path-title-plugin-undo-container" }, (el) => {
          const heading = replacementTypeToUi[pathSettings.type].heading(pathSettings.match);
          new import_obsidian.Setting(el).setDesc(`Replacement where ${heading} removed`).addButton((button) => {
            button.setButtonText("Undo");
            button.onClick(() => __async(this, null, function* () {
              this.plugin.settings.pathSettings.splice(index, 0, pathSettings);
              yield this.plugin.saveSettings();
              this.undoReplacementEntry = null;
              this.display();
            }));
          }).addExtraButton((button) => {
            button.setIcon("cross");
            button.onClick(() => {
              this.undoReplacementEntry = null;
              this.display();
            });
          });
        });
        continue;
      }
      let headingEl = null;
      let matchSetting = null;
      let replacementSetting = null;
      containerEl.createEl("h3", {}, (el) => {
        headingEl = el;
        setSettingUi(this.plugin.settings.pathSettings[index]);
      });
      new import_obsidian.Setting(containerEl).setName("Replacement Type").addDropdown((dropdown) => {
        dropdown.addOptions({
          exact: "Exact Path",
          folder: "Exact Folder in Path",
          text: "Exact Text in Path",
          regexp: "Regular Expression in Path"
        }).setValue(this.plugin.settings.pathSettings[index].type === "fuzzy" ? "regexp" : this.plugin.settings.pathSettings[index].type).onChange((value) => {
          this.plugin.settings.pathSettings[index].type = value;
          setSettingUi(this.plugin.settings.pathSettings[index]);
          this.plugin.saveSettings();
        });
      });
      matchSetting = new import_obsidian.Setting(containerEl).addText((text) => {
        text.setValue(pathSettings.match || "").onChange((value) => __async(this, null, function* () {
          this.plugin.settings.pathSettings[index].match = value;
          yield this.plugin.saveSettings();
          setSettingUi(this.plugin.settings.pathSettings[index]);
        }));
      });
      replacementSetting = new import_obsidian.Setting(containerEl).addText((text) => {
        text.setValue(pathSettings.replace || "").onChange((value) => __async(this, null, function* () {
          this.plugin.settings.pathSettings[index].replace = value;
          yield this.plugin.saveSettings();
        }));
      });
      setSettingUi(this.plugin.settings.pathSettings[index]);
      new import_obsidian.Setting(containerEl).addExtraButton((button) => {
        button.setIcon("trash").setTooltip("Remove replacement").onClick(() => __async(this, null, function* () {
          this.plugin.settings.pathSettings.splice(index, 1);
          yield this.plugin.saveSettings();
          this.undoReplacementEntry = [index, pathSettings];
          this.display();
        }));
      }).addExtraButton((button) => {
        button.setIcon("down-arrow-with-tail").setTooltip(index >= this.plugin.settings.pathSettings.length - 1 ? "Already last" : "Move replacement down").setDisabled(index >= this.plugin.settings.pathSettings.length - 1).onClick(() => __async(this, null, function* () {
          const pathSettings2 = this.plugin.settings.pathSettings[index];
          this.plugin.settings.pathSettings.splice(index, 1);
          this.plugin.settings.pathSettings.splice(index + 1, 0, pathSettings2);
          yield this.plugin.saveSettings();
          this.display();
        }));
      }).addExtraButton((button) => {
        button.setIcon("up-arrow-with-tail").setTooltip(index === 0 ? "Already first" : "Move replacement up").setDisabled(index === 0).onClick(() => __async(this, null, function* () {
          const pathSettings2 = this.plugin.settings.pathSettings[index];
          this.plugin.settings.pathSettings.splice(index, 1);
          this.plugin.settings.pathSettings.splice(index - 1, 0, pathSettings2);
          yield this.plugin.saveSettings();
          this.display();
        }));
      });
    }
  }
};

// main.ts
var main_default = PathTitlePlugin;
